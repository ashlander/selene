// This file is part of the `Selene` library.
// Copyright 2017-2019 Michael Hofmann (https://github.com/kmhofmann).
// Distributed under MIT license. See accompanying LICENSE file in the top-level directory.

#ifndef SELENE_TEST_UTILS_HPP
#define SELENE_TEST_UTILS_HPP

#include <selene/base/Promote.hpp>

#include <wrappers/fs/Filesystem.hpp>

#include <algorithm>
#include <numeric>
#include <random>
#include <type_traits>

namespace sln_test {

sln_fs::path get_tmp_path();
sln_fs::path full_data_path(const sln_fs::path& filename);

template <typename T> auto uniform_distribution(T lb, T ub)
{
  // http://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution:
  // The result type generated by the generator. The effect is undefined if this is not one of short, int, long,
  // long long, unsigned short, unsigned int, unsigned long, or unsigned long long.
  using DT = std::conditional_t<(sizeof(T) < sizeof(short)), sln::promote_t<T>, T>;

  constexpr auto is_int = std::is_integral_v<T>;
  constexpr auto is_fp = std::is_floating_point_v<T>;

  using DieType = std::conditional_t<is_int, std::uniform_int_distribution<DT>,
      std::conditional_t<is_fp, std::uniform_real_distribution<T>, void>>;
  return DieType(lb, ub);
}

inline std::vector<std::uint8_t> generate_random_data(std::size_t nr_bytes)
{
  std::independent_bits_engine<std::default_random_engine, 16, std::uint16_t> bytes_engine;
  std::vector<std::uint8_t> data(nr_bytes);
  std::for_each(data.begin(), data.end(), [&bytes_engine](auto& x) { x = static_cast<std::uint8_t>(bytes_engine()); });
  return data;
}

template <class T> class IotaAllocator
{
public:
  using size_type = std::size_t;
  using difference_type = std::ptrdiff_t;
  using pointer = T*;
  using const_pointer = const T*;
  using reference = T&;
  using const_reference = const T&;
  using value_type = T;

  explicit IotaAllocator(T value) : value_(value)
  { }

  template <class U> explicit IotaAllocator(const IotaAllocator<U>& other)
  {
    value_ = other.value_;
  }

  pointer allocate(size_type n, [[maybe_unused]] const void* hint = nullptr)
  {
    auto ptr = new T[n];
    std::iota(ptr, ptr + n, value_);
    return ptr;
  }

  void deallocate(pointer p, [[maybe_unused]] size_type n)
  {
    delete [] p;
  }

private:
  T value_{0};
  template <typename U> friend class Allocator;
};

}  // namespace sln_test

#endif  // SELENE_TEST_UTILS_HPP
