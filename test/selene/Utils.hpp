// This file is part of the `Selene` library.
// Copyright 2017-2019 Michael Hofmann (https://github.com/kmhofmann).
// Distributed under MIT license. See accompanying LICENSE file in the top-level directory.

#ifndef SELENE_TEST_UTILS_HPP
#define SELENE_TEST_UTILS_HPP

#include <selene/base/Promote.hpp>

#include <wrappers/fs/Filesystem.hpp>

#include <random>
#include <type_traits>

namespace sln_test {

inline sln_fs::path get_tmp_path()
{
  const auto tmp_path = sln_fs::temp_directory_path() / "selene_test";

  if (!sln_fs::exists(tmp_path))
  {
    sln_fs::create_directories(tmp_path);
  }

  return tmp_path;
}

inline sln_fs::path full_data_path(const sln_fs::path& filename)
{
  const auto env_var = std::getenv("SELENE_DATA_PATH");
  return (env_var)
      ? (sln_fs::path(env_var) / filename)
      : (sln_fs::path("../data") / filename);
}

template <typename T>
inline auto uniform_distribution(T lb, T ub)
{
  // http://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution:
  // The result type generated by the generator. The effect is undefined if this is not one of short, int, long,
  // long long, unsigned short, unsigned int, unsigned long, or unsigned long long.
  using DT = std::conditional_t<(sizeof(T) < sizeof(short)), sln::promote_t<T>, T>;

  constexpr auto is_int = std::is_integral_v<T>;
  constexpr auto is_fp = std::is_floating_point_v<T>;

  using DieType = std::conditional_t<is_int, std::uniform_int_distribution<DT>,
      std::conditional_t<is_fp, std::uniform_real_distribution<T>, void>>;
  return DieType(lb, ub);
}

inline std::vector<std::uint8_t> generate_random_data(std::size_t nr_bytes)
{
  std::independent_bits_engine<std::default_random_engine, 16, std::uint16_t> bytes_engine;
  std::vector<std::uint8_t> data(nr_bytes);
  std::for_each(data.begin(), data.end(), [&bytes_engine](auto& x) { x = static_cast<std::uint8_t>(bytes_engine()); });
  return data;
}

}  // namespace sln_test

#endif  // SELENE_TEST_UTILS_HPP
