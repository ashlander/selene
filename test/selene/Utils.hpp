// This file is part of the `Selene` library.
// Copyright 2017-2018 Michael Hofmann (https://github.com/kmhofmann).
// Distributed under MIT license. See accompanying LICENSE file in the top-level directory.

#ifndef SELENE_TEST_UTILS_HPP
#define SELENE_TEST_UTILS_HPP

#include <selene/base/Promote.hpp>

#include <wrappers/fs/Filesystem.hpp>

#include <random>
#include <type_traits>

namespace sln_test {

inline sln_fs::path get_tmp_path()
{
  const auto tmp_path = sln_fs::temp_directory_path() / "selene_test";

  if (!sln_fs::exists(tmp_path))
  {
    sln_fs::create_directories(tmp_path);
  }

  return tmp_path;
}

inline sln_fs::path full_data_path(const char* filename)
{
  const auto env_var = std::getenv("SELENE_DATA_PATH");
  return (env_var)
      ? (sln_fs::path(env_var) / sln_fs::path(filename))
      : (sln_fs::path("../data") / sln_fs::path(filename));
}

template <typename T>
inline auto uniform_distribution(T lb, T ub)
{
  // http://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution:
  // The result type generated by the generator. The effect is undefined if this is not one of short, int, long,
  // long long, unsigned short, unsigned int, unsigned long, or unsigned long long.
  using DT = std::conditional_t<(sizeof(T) < sizeof(short)), sln::promote_t<T>, T>;

  constexpr auto is_int = std::is_integral<T>::value;
  constexpr auto is_fp = std::is_floating_point<T>::value;

  using DieType = std::conditional_t<is_int, std::uniform_int_distribution<DT>,
      std::conditional_t<is_fp, std::uniform_real_distribution<T>, void>>;
  return DieType(lb, ub);
}

}  // namespace sln_test

#endif  // SELENE_TEST_UTILS_HPP
